In this essay, I will discuss the issues relating to the teaching of computer science that were raised in the article "A Debate on Teaching Computer Science" [Dijkstra et al 1989]. The structure of the paper is as follows: first I will briefly summarise Dijkstra's contribution and his reply. I will do this to illustrate what I consider to be his main points. I will then discuss the relevance of these points to the teaching of computer science. In the section after that I will summarise the points raised by the other contributors. As many points were repeated, I will give an overview of all the issues raised and discuss them. In the final section I will address some issues that were not raised and bring together my conclusions. Dijkstra originally presented the talk at the ACM Computer Science Education Conference in February 1989 and it was decided to print the text of the talk in CACM with other computer scientists entering into the debate. The editor of the Communications of the ACM, Peter Denning introduces the debate by describing Dijkstra as challenging "some of the basic assumptions on which our curricula are based" [Dijkstra et al 1989]. Dijkstra's basic position is that computer science consists of two radical novelties and that this has implications for the teaching of computer science especially introductory programming courses for first year students (I will use the terms "first years" and "first year students" to replace the term "freshmen"). A radical novelty is such a sharp discontinuity in thought that existing approaches cannot be used to reason about it and it is necessary to approach a radical novelty with a blank mind. The two radical novelties in computer science are the depth of conceptual hierarchies that occur in computer science and the fact that computers are the first large scale digital devices. Radical novelties require much work to come to grips with, and  people are not prepared to do this, so they pretend the radical novelties do not exist. Examples of this in computer science are software engineering and artificial intelligence. Dijkstra investigates the scientific and educational consequences, by examining what computer science is. He reduces this to the manipulation of symbols by computers. In order for meaningful manipulations to be made, a program must be written. He then defines a program as an abstract symbol manipulator, which can be turned into a concrete symbol manipulator by adding a computer to it. Programs are elaborate formulae that must be derived by mathematics. Dijkstra hopes that symbolic calculation will become an alternative to human reasoning. Computing will go beyond mathematics and applied logic because it deals with the "effective  use of formal methods" [Dijkstra et al 1989].  He points out that this view of computing science is not welcomed by many people, for various reasons.Dijkstra makes a number of recommendations for education. Bugs should be called errors since a program with an error is wrong, and lecturers should avoid anthropomorphic terminology as it causes students to compare the analog human with discrete computer and this leads to operational reasoning which is tremendous waste of time. When attempting to prove something about a set, it is better to work from the definition than with each individual item in the set. The approach can be applied to programming as well where programs can be reasoned about without dealing with specific behaviours of the program. The programmer's task is to prove that the program meets the functional specification. Dijkstra suggests that an introductory programming course for first years should consist of a boolean algebra component, and a program proving component. The language that will be used will be a simple imperative language with no implementation so that students cannot test their programs. Dijkstra argues that these proposals are too radical for many. The responses that he expects, are that he is out of touch with reality, that the material is too difficult for first years, and that it would differ from what first years expect. Dijkstra states that students would quickly learn that they can master a new tool (that of manipulating uninterpreted formulae) that, although simple, gives them a power they never expected. Dijkstra also states that teaching radical novelties is a way of guarding against dictatorships. In his reply to the panel's responses, Dijkstra points out that this is only a recommendation for an introductory programming course for first years. He notes that functional specifications fulfil the "pleasantness problem" - whether the product specified is the product wanted -, and the proof fulfils the "correctness problem" - whether the product implemented is the product specified and that these two problems require different techniques. He admits that the choice of functional specification and notation is not clear. He addresses concerns about the possibility of a more formalised mathematics and gives a number of reasons for his belief that it will be developed. Well chosen formalisms can give short proofs, logic has not been given a chance to provide an alternative to human reasoning, heuristic guidance can be obtained by syntactic analysis of theorems and informal mathematics is hard to teach because of things like "intuition", whereas symbol manipulation will be easy to teach. In this section, I will discuss some of the issues raised by Dijkstra. He has described the two radical novelties of computer science and he uses this as a justification for approaching the discipline with a blank mind, because previous knowledge cannot help in the understanding of computer science. He later advances an approach to computer science that involves taking a mathematical approach, by using existing techniques of predicate calculus to prove that programs meet their specifications. This would seem to contradict his argument that one cannot use the familiar to reason about a radical novelty.Generally it is accepted that to restrict thinking to one particular framework is undesirable, and leads to the formation of dictatorships. Dijkstra's argument is that students taking the introductory course should only think in the specified way. In my opinion, different approaches to a topic can only help comprehension of that topic. A point raised in a number of letters that appeared in later issues of Communications of the ACM is that different students approaching learning new concepts in different ways and that teaching should cater for this [Bernstein 1990; Herbison-Evans 1991]. Dijkstra also seems to have a general suspicion of tools, even those that can help students (or professionals) better understand a topic. A more pragmatic issue is that some students doing an introductory course at university will already have been exposed to programming and therefore operational thinking. How are these students to keep their thinking "pure" when doing Dijkstra's course? Dijkstra's approach to teaching seems to be one of training not education. He wants to teach students doing an introductory course, a rigid set of rules and that set of rules only. This does not leave room for intuition, judgement and discussion, which all relate to education. He also emphasises the need for a specific skill without grounding it in any larger context. One of the participants, William Scherlis, raised the question of why use an imperative language if operational thinking is to be avoided. Luker raises the point made by Turner and Backus that variables and assignment statements in imperative languages make verification difficult [Luker 1989].  A rigorous formalism could be introduced using a functional programming language (or perhaps using a formal language that does not relate to a programming language) and an understanding of the use of formalisms could be related to various issues of computer science and mathematics. This would give a broader area of application for the course. Dijkstra states that learning to manipulate uninterpreted formulae would be satisfying for a first year student as it would "give him a power that far surpasses his wildest dreams". I believe that a course of this kind would consist of boring and repetitive work that would become mechanical, as it is training and not education. It could give a student a sense of power, but only in a limited domain, and as I understand the course that Dijkstra has outlined, this knowledge could not be applied to other domains within computer science. Dijkstra states that operational reasoning is a  waste of time, however proving programs can be very time consuming (except with very powerful techniques that might be developed in the future).  Currently there is no formalism that is powerful enough to allow for short proofs and generally proving that a program is correct is a very tedious job. [De Millo et al 1979].I can agree with the basic theme of Dijkstra's recommendations. I do perceive that there is a lack of rigour in introductory courses in computer science. However I would not approach changing the curriculum as Dijkstra does and I do not think his suggestions have really challenged any basic assumptions about curricula. I feel that he is pandering to the view of "computer science is programming" by using program verification as a tool for developing rigour. I find it problematic that the more formalised mathematics required for proof have not yet been developed, as the current techniques seem insufficient. In my opinion, it would be more beneficial to introduce students to the concept of formal proof of programs and then discuss the current limitations of the approach. I would prefer an computer science discrete mathematics course to be presented during the first year curriculum, such as the suggestions made by Marion [Marion 1989]. In this course, rigour can be introduced but the material covered is related to computer science as a whole and not only to programming. In this section, I will summarise the responses to Dijkstra. A number of panelists agreed with Dijkstra's general conclusions although most people disagreed with his argument to justify the conclusions. A number of panelists also responded to his attack on software engineering. The responses that follow are those that relate to the teaching of computer science. In engineering education both proof and testing are necessary techniques and are not taught as alternatives. Students require exposure to the whole process of software engineering. Dijkstra does not tackle the issue of formalisation (capturing a real world problem  in a formal specification) and the fact that formalisation is difficult. Mathematical proofs are not found by symbol manipulation but by trial and error using intuition and any other tools that will help. Dijkstra is trying to restrict modes of thinking but intuition and operational thinking can help solve problems. There are a number of different approaches to programming such as imperative, functional and logic. Dijkstra's language is imperative and cannot be scaled up. Students need to be exposed to set theory and predicate calculus which can be used in both formal and informal proof, but there is more to computer science than symbol manipulation. Most panelists lost track of the fact that Dijkstra was careful enough to discuss his thoughts in terms of a first year course only and their discussion related mainly to issues of definition of computer science which are beyond the scope of this essay. However this did bring out very clearly that there is a lot of debate about what computer science is and what should be taught . This debate has been continued recently by the ACM Task Force on the Core of Computer Science [Denning et al 1989] and ACM/IEEE-CS Joint Curriculum Task Force [Tucker and Barnes 1991].My general feeling about this debate is that it did not address general issues of teaching computer science. In fact Dijkstra limits himself to discussing an introductory programming course and does not discuss the impact of this course on the rest of the curricula. The debate relates predominantly to the teaching of programming, a  pervasive part of computer science (see for example the section in the Task Force on The Role Of Programming [Denning et al 1989]), although I believe that the main issue was about rigour and formalism in introductory courses. In the Core of Computer Science Report and the Curricula 1991 Report, there is a heavier emphasis on theory in the curriculum than previously, however the issue of where it should be placed in the curriculum was not discussed.  I think that it has generally been agreed that rigour is necessary for a computer science undergraduate curriculum, but I think that the question of how the rigour is to be taught is still an open area and it is important to be aware that students have different learning styles. In my opinion, an essential point for any introductory course teaching rigour is that it must relate the material taught to the rest of computer science so that the students can appreciate its place in the curriculum and its relevance to the field.